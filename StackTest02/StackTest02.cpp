// StackTest02.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <stack>
#include <list>
#include <iostream>
#define STACK_SIZE  4   // 堆栈最大容量
using namespace std;

/***********************************堆栈的大小*********************************************************
	堆栈的元素个数可用 size 函数获得。每次元素入栈前，先检查当前堆栈的大小，超过某个界限值，则不允许元素入栈，以此可
实现一个具有一定容量限制的堆栈。

	size_type  size()		返回当前堆栈的元素个数

	下面的示例程序，将堆栈的大小设置为 100 个 int 元素，而且使用 list　双向链表做堆栈的底层容器，每次压入元素时均
判断堆栈的大小是否超过100个元素的界限，从而实现具有容量限制的堆栈。
****************************************************************************************************/


int _tmain(int argc, _TCHAR* argv[])
{
	// 用双向链表作堆栈的底层结构
	stack<int, list<int> >   s; 
	// 堆栈未满，元素才能入栈
	if (s.size() < STACK_SIZE)
		s.push(68);
	if (s.size() < STACK_SIZE)
		s.push(1);
	if (s.size() < STACK_SIZE)
		s.push(17);
	if (s.size() < STACK_SIZE)
		s.push(18);
	if (s.size() < STACK_SIZE)	// 栈满，不能够继续入栈了
		s.push(67);
	// 元素出栈
	while (!s.empty())
	{
		// 打印 18 17 1 68
		cout << s.top() << endl;
		s.pop();
	}
	return 0;
}

/**************************************stack  小结******************************************************
	堆栈是一种应用非常广泛的数据结构。C++ STL 将这种数据结构和它若干受限制操作用泛型类 stack 容器封装出来，包括堆栈
初始化、元素入栈、取栈顶元素、元素出栈、判断堆栈是否非空和取得当前堆栈大小等，应用起来十分容易。
	stack的元素出栈操作是不返回栈顶元素的，需要另外通过取栈顶函数获得。这种分离实现是考虑到出栈函数若直接返回栈顶元素
，将会导致返回值的数据引用安全问题或不必要的低效复制函数的调用。
	从 stack 内部实现看，stack 堆栈是不设最大容量的，但可通过 size 函数获取当前堆栈的大小，以判断是否允许继续让元素
入栈，实现具有最大容量限制的堆栈。
*******************************************************************************************************/