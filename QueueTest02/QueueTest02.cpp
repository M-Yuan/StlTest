// QueueTest02.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <queue>
#include <list>
#include <iostream>
#define QUEUE_SIZE  50

using namespace std;

/************************************队列的大小*******************************************************
	队列的元素个数可用 size 函数获取。如果每次元素入队前，都先检查当前队列的元素个数，以此判断是否再允许元素入队，
那么就可实现一个具有固定长队的队列。如下是 size 函数的使用原型：

	size_type  size()

	下面的示例程序，将 queue 队列的长队设置为 50 个 int 元素，并使用 list 双向链表作底层结构，每当元素入队时，
都调用 size 函数检查长度是否会超过限定的长度界限，实现一个固定大小的 queue 队列。
****************************************************************************************************/

int _tmain(int argc, _TCHAR* argv[])
{
	// 用双向链表作 queue 队列的底层容器
	queue<int, list<int> >   q;
	if (q.size() < QUEUE_SIZE)
		q.push(51);
	if (q.size() < QUEUE_SIZE)
		q.push(36);
	if (q.size() < QUEUE_SIZE)
		q.push(28);
	if (q.size() < QUEUE_SIZE)
		q.push(1);
	// 元素出对
	while (!q.empty())
	{
		// 打印 51  36  28  1
		cout << q.front() << "  " <<endl;
		// 出对
		q.pop();
	}

	cout << endl;
	return 0;
}

/**************************************queue  小结******************************************************
	队列也是一种常用的数据结构，通常以消息队列的形式应用与进程间的通信。C++ STL 提供的 queue 容器队列的数据结构和受限操作
进行了泛化封装，包括队列初始化、元素入队、取队首元素、元素出对、队列是否为空以及获取当前队列长度等操作。
	与堆栈一样，queue 队列也是默认使用 queue 双端队列作底层架构，元素的出对也不返回队首元素，需要先用取队首函数将之读出。
通过检查当前队列长度，来决定是否允许元素入队，可实现具有固定长度的队列。
*******************************************************************************************************/

